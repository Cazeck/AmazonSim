
from Point import Point

"""
    Credit to Nicolas Swift for the A* pathing algorithm, found from his article on medium.com
    Made some changes in order for it to produce the result I was looking for and tailor it to the warehouse
    floor layout
"""


class Node:
    """
    This is the Node class we use during the aStar path finding algorithm

    Attributes:
        parent: Tuple representing the point location of the parent node (x, y)
        position: Tuple representing the point location of the the node (x, y)
        g: Integer value representing the distance between the current node and start node
        h: Integer value representing the heuristic, the estimated distance from the current node to end node
        f: Integer value representing the total cost of the node

    """

    def __init__(self, parent=None, position=None):
        self.parent = parent
        self.position = position

        self.g = 0
        self.h = 0
        self.f = 0

    def __eq__(self, other):
        return self.position == other.position


def aStar(grid, start, end):
    """
    Implementation of the A* pathfinding algorithm to help us create a path through our warehouse without
    colliding into objects

    Returns a list of tuples as a path from the given starting location to the given end location in the given grid

    Args
        grid: A matrix grid of the warehouse floor layout. This is generated by and explained within the
            floorGrid function within Floor
        start: Point object where the path starts
        end: Point object where the path ends

    Returns
        reversed_path[1:]: A list of Point objects in the order of the path needed to be taken from
            start location to end location. 1st location is excluded because that is the location
            where the robot is currently at
    """

    # We convert the Point objects into tuples here because it simply works better with the pathing
    # algorithm we are using. We convert these back into Point objects at the end.

    # Create start and end nodes and switch the x & y positions within the tuples
    # We switch the x & y positions because our Warehouse floor is inverse to how the algorithm works
    rev_start = (start.y, start.x)
    rev_end = (end.y, end.x)

    start_node = Node(None, rev_start)
    start_node.g = start_node.h = start_node.f = 0
    end_node = Node(None,  rev_end)
    end_node.g = end_node.h = end_node.f = 0

    # Initialize both open and closed list
    open_list = []
    closed_list = []

    # Add the start node
    open_list.append(start_node)

    # Loop until you find the end
    while len(open_list) > 0:

        # Get the current node
        current_node = open_list[0]
        current_index = 0
        for index, item in enumerate(open_list):
            if item.f < current_node.f:
                current_node = item
                current_index = index

        # Pop current off open list, add to closed list
        open_list.pop(current_index)
        closed_list.append(current_node)

        # Found the goal
        if current_node == end_node:
            path = []
            current = current_node
            while current is not None:
                # (y, x) switch to (x, y)
                # We switch x & y positions here to match back up with the layout of Warehouse Floor and
                # create a Point object to add to path
                new_point = Point(current.position[1], current.position[0])
                path.append(new_point)
                current = current.parent

            reversed_path = path[::-1]
            return reversed_path[1:]    # Return reversed path without first element (Robot current location)

        # Generate children
        children = []
        adjacent_squares = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        for new_position in adjacent_squares:

            # Get node position
            node_position = (current_node.position[0] + new_position[0],
                             current_node.position[1] + new_position[1])

            # Make sure within range
            if node_position[0] > (len(grid) - 1) or node_position[0] < 0 \
                    or node_position[1] > (len(grid[len(grid)-1]) - 1) or node_position[1] < 0:
                continue

            # New added to stop loop
            # Check if neighbor is already in the closed list
            if Node(current_node, node_position) in closed_list:
                continue

            # Make sure walkable terrain
            if grid[node_position[0]][node_position[1]] != 0:
                continue

            # Create new node
            new_node = Node(current_node, node_position)

            # Append
            children.append(new_node)

        # Loop through children
        for child in children:

            # Child is on the closed list
            for closed_child in closed_list:
                if child == closed_child:
                    break

            # Create the f, g, and h values
            child.g = current_node.g + 1
            child.h = ((child.position[1] - end_node.position[1]) ** 2)\
                      + ((child.position[0] - end_node.position[0]) ** 2)
            child.f = child.g + child.h

            # Child is already in the open list
            for open_node in open_list:
                if child == open_node and child.g >= open_node.g:
                    break

            # Add the child to the open list
            open_list.append(child)

# For testing

#def main():

    #maze = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    #        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    #        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    #        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    #        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    #        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    #        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    #        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    #        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    #        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

    #floor = [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    #         [1, 1, 0, 0, 0, 1, 1, 1, 1, 1],
    #         [1, 0, 0, 0, 0, 1, 1, 1, 0, 1],
    #         [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    #         [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    #         [1, 0, 0, 0, 0, 1, 1, 1, 1, 1],
    #         [1, 0, 0, 0, 0, 1, 1, 1, 1, 1],
    #         [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    #         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    #         [0, 0, 1, 1, 1, 0, 1, 0, 0, 0]]

    #start = Point(5, 9) # (5, 9) robot
    #end = Point(8, 2)   # (8, 2) shelf

    #path = aStar(floor, start, end)

    #print(path)


#if __name__ == '__main__':
#    main()
